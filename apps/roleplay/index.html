<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>RP Chat (OpenRouter)</title>
  <style>
    :root{
      --bg0:#2b2219;
      --bg1:#32271d;
      --bg2:#3a2e23;
      --card:#3f3226;
      --line:#5e4a38;
      --text:#f1e4d2;
      --muted:#c2b09a;
      --accent:#d8a463;
      --good:#7aa06b;
      --warn:#c59a55;
      --bad:#c06a5b;
      --shadow: 0 10px 30px rgba(10,7,5,.55);
      --radius: 14px;
      --sidebar-width: clamp(260px, 28vw, 420px);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --glass-bg: rgba(63,50,38,.64);
      --glass-border: rgba(216,200,178,.28);
      --glass-highlight: rgba(255,235,206,.16);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: var(--bg0);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
    }
    .app{
      display:grid;
      grid-template-columns: var(--sidebar-width) minmax(0, 1fr);
      height:100vh;
      box-shadow: inset 0 0 0 1px var(--line);
    }
    .sidebarBackdrop{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.25);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index:15;
    }
    .sidebar{
      width: var(--sidebar-width);
      border-right:1px solid var(--line);
      background:
        linear-gradient(160deg, rgba(255,235,206,.08), rgba(0,0,0,0) 45%),
        linear-gradient(200deg, rgba(216,164,99,.12), rgba(58,45,34,.65));
      overflow:visible;
      transition: transform .18s ease, opacity .18s ease;
      position:relative;
      z-index:16;
      box-shadow: inset 0 1px 0 rgba(255,235,206,.18), var(--shadow);
    }
    .sidebarScroll{
      height:100%;
      overflow:auto;
      padding:14px 16px 16px 16px;
    }
    .app.sidebar-hidden{
      grid-template-columns: 1fr;
    }
    .app.sidebar-hidden .sidebar{
      transform: translateX(-100%);
      opacity:0;
      pointer-events:none;
      width:0;
      padding:0;
      border-right:0;
      overflow:hidden;
    }
    .app.sidebar-hidden .sidebarScroll{
      padding:0;
      overflow:hidden;
    }
    .app.sidebar-open .sidebar{
      transform: translateX(0);
      opacity:1;
      pointer-events:auto;
    }
    .app.sidebar-open .sidebarBackdrop{
      opacity:1;
      pointer-events:auto;
    }
    .brand{
      display:flex; gap:10px; align-items:center;
      padding:10px 12px;
      border:1px solid var(--line);
      background:
        linear-gradient(160deg, rgba(255,235,206,.1), rgba(0,0,0,0) 45%),
        rgba(63,50,38,.85);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .sidebarToggle{
      width:auto;
      padding:8px 10px;
      font-size:12px;
      border-radius:10px;
    }
    .sidebarEdgeToggle{
      position:static;
      margin:0 0 12px 0;
      align-self:flex-start;
    }
    .brandLogo{
      width:70px;
      height:70px;
      border-radius:8px;
      object-fit:contain;
      background: rgba(58,45,34,.9);
      border:1px solid var(--line);
      padding:0;
    }
    .brand h1{font-size:14px;margin:0}
    .brand p{margin:2px 0 0 0; font-size:12px; color: var(--muted)}
    .panel{
      margin-top:14px;
      border:1px solid var(--line);
      background:
        linear-gradient(160deg, rgba(255,235,206,.08), rgba(0,0,0,0) 45%),
        rgba(63,50,38,.82);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:12px;
    }
    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .panelToggle{
      width:auto;
      padding:6px 8px;
      font-size:11px;
      border-radius:8px;
    }
    .panelBody{margin-top:8px;}
    .tabs{
      margin-top:12px;
      display:flex;
      gap:8px;
    }
    .tab{
      width:auto;
      padding:8px 10px;
      font-size:12px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(58,45,34,.9);
      color: var(--muted);
      cursor:pointer;
    }
    .tab.active{
      color: var(--text);
      border-color: rgba(216,164,99,.45);
      background: rgba(216,164,99,.18);
    }
    .chatList{
      margin-top:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .characterList{
      margin-top:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .charCard{
      border:1px solid var(--line);
      border-radius:10px;
      background: rgba(58,45,34,.7);
      padding:10px;
    }
    .charHeader{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .charNameInput{
      flex:1;
      min-width:0;
    }
    .charActions{
      display:flex;
      gap:6px;
      align-items:center;
    }
    .charToggle, .charDelete{
      width:auto;
      padding:4px 6px;
      font-size:11px;
      border-radius:8px;
    }
    .charBody{margin-top:8px;}
    .chatItem{
      display:flex;
      gap:8px;
      align-items:flex-start;
      padding:8px;
      border:1px solid var(--line);
      border-radius:10px;
      background: rgba(58,45,34,.7);
      cursor:pointer;
    }
    .chatItem.active{
      border-color: rgba(216,164,99,.45);
      background: rgba(216,164,99,.14);
    }
    .chatInfo{flex:1; min-width:0}
    .chatTitle{
      font-size:12px;
      font-weight:650;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .chatMeta{
      font-size:11px;
      color: var(--muted);
      margin-top:4px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .chatDelete{
      width:auto;
      padding:4px 6px;
      font-size:11px;
      border-radius:8px;
      background: rgba(58,45,34,.75);
      border:1px solid rgba(216,200,178,.2);
    }
    .panel h2{
      font-size:12px;
      margin:0 0 10px 0;
      color: var(--muted);
      letter-spacing:.08em;
      text-transform:uppercase;
    }
    label{
      display:block;
      font-size:12px;
      color: var(--muted);
      margin:10px 0 6px;
    }
    input, select, textarea, button{
      width:100%;
      border:1px solid var(--line);
      background: rgba(58,45,34,.82);
      color: var(--text);
      border-radius: 10px;
      padding:10px;
      outline:none;
      font-size:13px;
    }
    textarea{resize:vertical; min-height:70px; line-height:1.35;}
    .row{display:flex; gap:10px}
    .row > *{flex:1}
    button{
      cursor:pointer;
      background: rgba(216,164,99,.18);
      border:1px solid rgba(216,164,99,.45);
      transition: .15s ease;
    }
    button:hover{transform: translateY(-1px); background: rgba(216,164,99,.26)}
    .sidebar button,
    .sidebar .tab,
    .sidebar .chip,
    .sidebar .chatItem{
      transition: transform .15s ease, background-color .15s ease, border-color .15s ease, box-shadow .15s ease;
      will-change: transform;
    }
    @media (hover: hover) and (pointer: fine){
      .sidebar button:hover,
      .sidebar .tab:hover,
      .sidebar .chip:hover,
      .sidebar .chatItem:hover{
        transform: translateY(-1px);
        box-shadow: 0 8px 18px rgba(10,7,5,.28);
      }
    }

    button.secondary{
      background: rgba(58,45,34,.75);
      border:1px solid rgba(216,200,178,.2);
    }
    button.danger{
      background: rgba(192,106,91,.16);
      border:1px solid rgba(192,106,91,.38);
    }
    .mini{
      font-size:11px;
      color: var(--muted);
      margin-top:8px;
      line-height:1.3;
    }
    .chips{
      display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;
    }
    .chip{
      font-size:11px;
      padding:6px 9px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(58,45,34,.8);
      color: var(--muted);
      cursor:pointer;
      user-select:none;
    }
    .chip.active{
      border-color: rgba(216,164,99,.45);
      color: var(--text);
      background: rgba(216,164,99,.18);
    }

    /* MAIN CHAT */
    .main{
      display:flex;
      flex-direction:column;
      height:100vh;
      min-width:0;
    }
    .topbar{
      border-bottom:1px solid var(--line);
      background: rgba(58,45,34,.92);
      padding:14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .sideToggle{
      width:auto;
      padding:8px 10px;
      font-size:12px;
      flex:0 0 auto;
    }
    .titleBlock{
      display:flex;
      flex-direction:column;
      gap:3px;
      min-width: 0;
    }
    .titleBlock .title{
      font-size:14px;
      font-weight:650;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .titleBlock .sub{
      font-size:12px;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .topActions{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .topActions button{
      width:auto;
      padding:8px 10px;
      font-size:12px;
    }

    .chat{
      flex:1;
      overflow:auto;
      padding:18px 16px 120px;
      min-width:0;
    }
    .msg{
      max-width: 880px;
      margin: 0 auto 12px auto;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .avatar{
      width:34px; height:34px;
      border-radius:12px;
      background: rgba(88,70,54,.6);
      border:1px solid var(--line);
      flex: 0 0 34px;
      display:grid;
      place-items:center;
      color: var(--muted);
      font-weight:700;
      font-size:12px;
    }
    .bubble{
      flex:1;
      border:1px solid var(--line);
      background: rgba(63,50,38,.9);
      border-radius: 16px;
      padding: 12px 12px;
      line-height:1.45;
      box-shadow: 0 8px 24px rgba(58,45,34,.12);
      white-space:normal;
      word-break:break-word;
    }
    .bubble.user{
      background: rgba(216,164,99,.2);
      border-color: rgba(216,164,99,.4);
    }
    .bubble p{margin:0 0 8px}
    .bubble p:last-child{margin-bottom:0}
    .bubble ul, .bubble ol{
      margin:6px 0 8px 18px;
      padding:0;
    }
    .bubble li{margin:4px 0}
    .bubble pre{
      margin:8px 0;
      background: rgba(0,0,0,.25);
      border:1px solid var(--line);
      padding:10px;
      border-radius:10px;
      overflow:auto;
    }
    .bubble code{
      font-family: var(--mono);
      background: rgba(0,0,0,.25);
      padding:1px 4px;
      border-radius:6px;
      font-size:12px;
    }
    .bubble pre code{
      background: transparent;
      padding:0;
      font-size:12px;
    }
    .bubble a{
      color: var(--accent);
      text-decoration:none;
      border-bottom:1px solid rgba(216,164,99,.45);
    }
    .bubble a:hover{text-decoration:underline}
    .metaLine{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:11px;
      color: var(--muted);
      margin-top:8px;
    }
    .metaLine .mono{font-family: var(--mono)}
    .msgActions{
      display:flex;
      gap:6px;
      justify-content:flex-end;
      margin-top:6px;
    }
    .msgActions button{
      width:auto;
      padding:4px 8px;
      font-size:11px;
      border-radius:8px;
      background: rgba(58,45,34,.8);
      border:1px solid rgba(216,200,178,.2);
      color: var(--muted);
    }
    .msgActions button:hover{
      color: var(--text);
      border-color: rgba(216,164,99,.45);
    }
    .variantNav{
      display:flex;
      gap:6px;
      justify-content:flex-end;
      align-items:center;
      margin-top:6px;
      font-size:11px;
      color: var(--muted);
    }
    .variantNav button{
      width:auto;
      padding:2px 6px;
      font-size:11px;
      border-radius:8px;
      background: rgba(58,45,34,.8);
      border:1px solid rgba(216,200,178,.2);
      color: var(--muted);
    }
    .variantNav button:hover{
      color: var(--text);
      border-color: rgba(216,164,99,.45);
    }
    .editBox{
      width:100%;
      min-height:0;
      border:1px solid var(--line);
      background: rgba(58,45,34,.95);
      color: var(--text);
      border-radius:10px;
      padding:10px;
      font-size:inherit;
      line-height:1.45;
      overflow:hidden;
      resize:vertical;
    }
    .editActions{
      display:flex;
      gap:8px;
      justify-content:flex-end;
      margin-top:6px;
    }
    .editActions button{
      width:auto;
      padding:4px 8px;
      font-size:11px;
      border-radius:8px;
    }
    .composer{
      position:relative;
      bottom:0;
      padding:12px 14px 14px;
      background: linear-gradient(180deg, rgba(43,34,25,0), rgba(43,34,25,.9) 40%, rgba(43,34,25,.98));
      border-top:1px solid rgba(94,74,56,.6);
      backdrop-filter: blur(8px);
      flex-shrink:0;
    }
    .composerInner{
      max-width: 920px;
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:stretch;
    }
    .composer textarea{
      min-height: 52px;
      max-height: 160px;
      width:100%;
    }
    .inputRow{
      display:flex;
      gap:10px;
      align-items:stretch;
    }
    .inputRow textarea{flex:1}
    .sendBtn{
      width:44px;
      min-height:52px;
      padding:0;
      font-size:18px;
      font-weight:700;
    }
    .btnRow{
      display:flex;
      gap:8px;
    }
    .btnRow button{
      width:auto;
      flex:1;
    }
    .status{
      font-size:12px;
      color: var(--muted);
      margin-top:8px;
      max-width:920px;
      margin-left:auto;
      margin-right:auto;
    }
    .kbd{
      font-family: var(--mono);
      font-size:11px;
      padding:2px 6px;
      border:1px solid var(--line);
      border-radius:8px;
      background: rgba(58,45,34,.85);
      color: var(--muted);
    }
    @media (max-width: 980px){
      .app{grid-template-columns: 1fr}
      .sidebar{
        position: fixed;
        top:0;
        bottom:0;
        left:0;
        width: min(360px, 88vw);
        transform: translateX(-100%);
        opacity:0;
        pointer-events:none;
        z-index:20;
      }
      .topbar{
        flex-wrap:wrap;
        align-items:flex-start;
        justify-content:flex-start;
      }
      .sideToggle{order:1}
      .titleBlock{
        order:2;
        flex:1 1 100%;
        min-width:100%;
      }
      .topActions{
        order:3;
        width:100%;
        justify-content:flex-start;
      }
      .btnRow{width:100%}
      .composer{left:0}
    }
    @media (max-width: 720px){
      .chat{padding:14px 12px 60px}
    }
    @media (max-width: 520px){
      .panel{padding:10px}
      .bubble{padding:10px}
      .avatar{width:30px;height:30px; flex:0 0 30px; border-radius:10px}
    }
  </style>
</head>
<body>
<div class="app">
  <!-- SIDEBAR -->
  <aside class="sidebar">
    <div class="sidebarScroll">
      <button class="secondary sidebarToggle sidebarEdgeToggle" id="btnSidebarInside">Side View</button>
      <div class="brand">
        <img src="logo.png" class="brandLogo" alt="Logo" />
        <div>
          <h1>RP Chat Builder</h1>
          <p>OpenRouter • Character Card • Lore • Memory</p>
        </div>
      </div>
      <div class="tabs" id="sidebarTabs">
        <button class="tab active" data-tab="chats">Chats</button>
        <button class="tab" data-tab="current">Current Chat</button>
        <button class="tab" data-tab="settings">Settings</button>
      </div>

      <div class="panel chatsPanel">
        <h2>Chats</h2>
        <div class="row" style="margin-top:6px">
          <button id="btnNewChat">New Chat</button>
        </div>
        <div class="chatList" id="chatList"></div>
      </div>

      <div class="panel settingsPanel">
        <h2>Connection</h2>

      <div class="chips" id="modeChips">
        <div class="chip active" data-mode="direct">Direct Mode</div>
        <div class="chip" data-mode="proxy">Proxy Mode</div>
      </div>

      <div id="directFields">
        <label>OpenRouter API Key (saved locally)</label>
        <input id="apiKey" placeholder="sk-or-..." type="password" />
      </div>

      <div id="proxyFields" style="display:none">
        <label>Proxy Base URL</label>
        <input id="proxyBase" placeholder="https://your-worker.yourdomain.com" />
        <div class="mini">Proxy Mode is the safe way to launch publicly. Frontend calls <span class="kbd">/api/chat</span> instead of OpenRouter directly.</div>
      </div>

      <div class="row" style="margin-top:10px">
        <button class="secondary" id="btnTest">Test Connection</button>
        <button id="btnLoadModels">Load Models</button>
      </div>

      <label>Model</label>
      <select id="modelSelect">
        <option value="">(load models or type below)</option>
      </select>

      <label>Or type model ID</label>
      <input id="modelManual" placeholder="e.g. openai/gpt-5.2 or anthropic/claude-..." />

      <div class="mini">Models list comes from <span class="kbd">GET https://openrouter.ai/api/v1/models</span>. :contentReference[oaicite:2]{index=2}</div>
    </div>

    <div class="panel currentPanel" data-collapsible="character">
      <div class="panelHeader">
        <h2>Characters</h2>
        <div class="charActions">
          <button class="secondary" id="btnAddChar" type="button">Add Character</button>
          <button class="secondary panelToggle" type="button" data-target="character">Hide</button>
        </div>
      </div>
      <div class="panelBody" data-body="character">
        <label>Reply As</label>
        <div class="row">
          <select id="replyAsSelect"></select>
          <button class="secondary" id="btnForceReply" type="button">Force Reply</button>
        </div>
        <div class="characterList" id="characterList"></div>
        <div class="mini">Each character has its own persona. Auto uses name and recent speaker.</div>
      </div>
    </div>

    <div class="panel currentPanel">
      <h2>Scene & Style</h2>
      <label>Scene / Setting</label>
      <textarea id="sceneSetting" placeholder="Where are we? What's happening?"></textarea>

      <label>Style Rules (global)</label>
      <textarea id="styleRules" placeholder="Formatting & pacing rules (ex: no OOC, write in 1st person...)"></textarea>
    </div>

    <div class="panel currentPanel">
      <h2>Lorebook (simple)</h2>
      <label>Lore Entries (JSON)</label>
      <textarea id="loreJson" style="min-height:120px" placeholder='[
  {"keys":["academy","principal"],"text":"The Academy is a fortress-school ruled by Principal Veyra."},
  {"keys":["moonblade"],"text":"Moonblade is the only weapon that can cut shadow-kin."}
]'></textarea>
      <div class="mini">We’ll auto-inject lore entries when keywords show up in the last messages.</div>
    </div>

    <div class="panel settingsPanel">
      <h2>Generation</h2>
      <div class="row">
        <div>
          <label>Temperature</label>
          <input id="temp" type="number" min="0" max="2" step="0.05" value="0.9"/>
        </div>
        <div>
          <label>Max Tokens</label>
          <input id="maxTokens" type="number" min="64" max="8192" step="64" value="600"/>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Top P</label>
          <input id="topP" type="number" min="0" max="1" step="0.05" value="0.9"/>
        </div>
        <div>
          <label>Presence Penalty</label>
          <input id="presence" type="number" min="-2" max="2" step="0.1" value="0.2"/>
        </div>
      </div>

      <label><input id="streamToggle" type="checkbox" checked style="width:auto; margin-right:8px"> Streaming</label>
      <div class="mini">Streaming uses SSE chunks (<span class="kbd">stream: true</span>). :contentReference[oaicite:3]{index=3}</div>
    </div>
  </div>
  </aside>
  <div class="sidebarBackdrop" id="sidebarBackdrop" aria-hidden="true"></div>

  <!-- MAIN -->
  <main class="main">
    <div class="topbar">
      <button class="secondary sideToggle" id="btnSidebar">Side View</button>
      <div class="titleBlock">
        <div class="title" id="topTitle">New Chat</div>
        <div class="sub" id="topSub">Not connected</div>
      </div>
      <div class="topActions">
        <button class="secondary" id="btnExport">Export Chat</button>
        <button class="secondary" id="btnImport">Import Chat</button>
        <button class="danger" id="btnClear">Clear</button>
      </div>
    </div>

    <div class="chat" id="chat"></div>

    <div class="composer">
      <div class="composerInner">
        <div class="inputRow">
          <textarea id="input" placeholder="Write your next message... (Shift+Enter = newline)"></textarea>
          <button id="btnSend" class="sendBtn" aria-label="Send message">&gt;</button>
        </div>
        <div class="btnRow">
          <button class="secondary" id="btnRegen">Regenerate</button>
          <button class="danger" id="btnStop">Stop</button>
        </div>
      </div>
      <div class="status" id="status">
        Tip: <span class="kbd">Enter</span> sends • <span class="kbd">Shift</span>+<span class="kbd">Enter</span> newline
      </div>
    </div>
  </main>
</div>

<script>
/* =========================
   RP CHAT (OpenRouter)
   - Direct Mode (api key in UI)
   - Proxy Mode (calls your backend)
   ========================= */

const $ = (id)=>document.getElementById(id);

const appEl = document.querySelector(".app");
const chatEl = $("chat");
const statusEl = $("status");
const inputEl = $("input");

let aborter = null;
let editingIndex = null;

const LS_KEY = "rpchat_state_v1";
const DEFAULT_MODEL = "mistralai/devstral-2512:free";
const DEFAULT_CHARACTER = {
  name: "",
  persona: ""
};
const DEFAULT_CHAT = {
  characters: [],
  scene: "",
  style: "",
  loreJson: "[]",
  gen: {
    temperature: 0.9,
    max_tokens: 600,
    top_p: 0.9,
    presence_penalty: 0.2,
    stream: true
  },
  messages: [],
  usage: null,
  replyAs: "auto",
  lastReplyCharacterId: null,
  characterCollapsed: {}
};

function cloneDefaultChat(){
  return JSON.parse(JSON.stringify(DEFAULT_CHAT));
}
function cloneDefaultCharacter(){
  return JSON.parse(JSON.stringify(DEFAULT_CHARACTER));
}
function makeChatId(){
  return "chat_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 8);
}
function makeCharId(){
  return "char_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 8);
}
function normalizeCharacter(character){
  const base = cloneDefaultCharacter();
  const c = { ...base, ...(character || {}) };
  if(!c.id) c.id = makeCharId();
  return c;
}
function createCharacter(overrides = {}){
  const base = cloneDefaultCharacter();
  return {
    id: makeCharId(),
    ...base,
    ...overrides
  };
}
function ensureCharacters(chat){
  if(chat.char && !chat.characters){
    chat.characters = [createCharacter(chat.char)];
    delete chat.char;
  }
  if(!Array.isArray(chat.characters)) chat.characters = [];
  if(chat.characters.length === 0){
    chat.characters.push(createCharacter({ name: "Assistant" }));
  }
  chat.characters = chat.characters.map(c=>normalizeCharacter(c));
  if(!chat.replyAs) chat.replyAs = "auto";
  if(!chat.characterCollapsed || typeof chat.characterCollapsed !== "object") chat.characterCollapsed = {};
  if(chat.replyAs !== "auto" && !chat.characters.find(c=>c.id === chat.replyAs)) chat.replyAs = "auto";
  if(chat.lastReplyCharacterId && !chat.characters.find(c=>c.id === chat.lastReplyCharacterId)){
    chat.lastReplyCharacterId = null;
  }
}
function normalizeChat(chat){
  const base = cloneDefaultChat();
  if(!chat || typeof chat !== "object") return createChat();
  if(typeof chat.scene !== "string") chat.scene = base.scene;
  if(typeof chat.style !== "string") chat.style = base.style;
  if(typeof chat.loreJson !== "string") chat.loreJson = base.loreJson;
  chat.gen = { ...base.gen, ...(chat.gen || {}) };
  if(!Array.isArray(chat.messages)) chat.messages = [];
  if(chat.usage === undefined) chat.usage = base.usage;
  if(chat.replyAs === undefined) chat.replyAs = base.replyAs;
  if(chat.lastReplyCharacterId === undefined) chat.lastReplyCharacterId = base.lastReplyCharacterId;
  if(!chat.characterCollapsed || typeof chat.characterCollapsed !== "object") chat.characterCollapsed = base.characterCollapsed;
  ensureCharacters(chat);
  if(!chat.scene){
    const legacyScene = chat.characters.find(c=>c.scenario)?.scenario;
    if(typeof legacyScene === "string") chat.scene = legacyScene;
  }
  if(!chat.style){
    const legacyStyle = chat.characters.find(c=>c.style)?.style;
    if(typeof legacyStyle === "string") chat.style = legacyStyle;
  }
  chat.characters.forEach(c=>{
    delete c.keywords;
    delete c.scenario;
    delete c.style;
    delete c.examples;
  });
  if(!chat.id) chat.id = makeChatId();
  if(!chat.createdAt) chat.createdAt = Date.now();
  if(!chat.updatedAt) chat.updatedAt = chat.createdAt;
  updateChatTitle(chat);
  return chat;
}
function createChat(overrides = {}){
  const base = cloneDefaultChat();
  const now = Date.now();
  const chat = {
    id: makeChatId(),
    title: "New Chat",
    createdAt: now,
    updatedAt: now,
    ...base,
    ...overrides
  };
  ensureCharacters(chat);
  updateChatTitle(chat);
  return chat;
}
let state = loadState() || {
  mode: "direct",
  apiKey: "",
  proxyBase: "",
  model: DEFAULT_MODEL,
  modelManual: "",
  sidebarOpen: true,
  sidebarTab: "chats",
  charCardCollapsed: false,
  chats: [createChat()],
  currentChatId: null
};

if(!state.chats){
  const legacyChars = state.char ? [createCharacter(state.char)] : [];
  const legacyChat = createChat({
    characters: legacyChars,
    loreJson: typeof state.loreJson === "string" ? state.loreJson : DEFAULT_CHAT.loreJson,
    gen: state.gen || DEFAULT_CHAT.gen,
    messages: Array.isArray(state.messages) ? state.messages : DEFAULT_CHAT.messages,
    usage: state.usage ?? null,
    replyAs: "auto",
    lastReplyCharacterId: null,
    characterCollapsed: {}
  });
  state.chats = [legacyChat];
  state.currentChatId = legacyChat.id;
}
if(!Array.isArray(state.chats) || state.chats.length === 0){
  const newChat = createChat();
  state.chats = [newChat];
  state.currentChatId = newChat.id;
}
state.chats = state.chats.map(chat=>normalizeChat(chat));
if(!state.currentChatId && state.chats[0]) state.currentChatId = state.chats[0].id;
if(!state.chats.find(c=>c.id === state.currentChatId) && state.chats[0]){
  state.currentChatId = state.chats[0].id;
}

if(state.sidebarOpen === undefined) state.sidebarOpen = true;
if(state.sidebarTab === "build") state.sidebarTab = "current";
if(!state.sidebarTab) state.sidebarTab = "chats";
if(state.charCardCollapsed === undefined) state.charCardCollapsed = false;
if(!state.modelManual && !state.model) state.model = DEFAULT_MODEL;
let modelsAutoLoaded = false;

renderAll();
wireUI();

function wireUI(){
  // Mode chips
  document.querySelectorAll("#modeChips .chip").forEach(chip=>{
    chip.addEventListener("click", ()=>{
      document.querySelectorAll("#modeChips .chip").forEach(c=>c.classList.remove("active"));
      chip.classList.add("active");
      state.mode = chip.dataset.mode;
      updateModeFields();
      saveState();
      updateTopSub();
      tryAutoLoadModels();
    });
  });

  // Sidebar tabs
  document.querySelectorAll("#sidebarTabs .tab").forEach(tab=>{
    tab.addEventListener("click", ()=>{
      state.sidebarTab = tab.dataset.tab || "chats";
      applySidebarTab();
      saveState();
    });
  });
  const charToggle = document.querySelector(".panelToggle[data-target=\"character\"]");
  if(charToggle){
    charToggle.addEventListener("click", ()=>{
      state.charCardCollapsed = !state.charCardCollapsed;
      applyCharacterCardCollapse();
      saveState();
    });
  }

  $("apiKey").addEventListener("input", e=>{ state.apiKey = e.target.value; saveState(); tryAutoLoadModels(); });
  $("proxyBase").addEventListener("input", e=>{ state.proxyBase = e.target.value; saveState(); updateTopSub(); tryAutoLoadModels(); });

  $("btnTest").addEventListener("click", testConnection);
  $("btnLoadModels").addEventListener("click", loadModels);

  $("modelSelect").addEventListener("change", e=>{
    state.model = e.target.value;
    if(!state.model) state.model = DEFAULT_MODEL;
    $("modelManual").value = "";
    state.modelManual = "";
    saveState();
    updateTopSub();
  });
  $("modelManual").addEventListener("input", e=>{
    state.modelManual = e.target.value.trim();
    if(state.modelManual) {
      $("modelSelect").value = "";
      state.model = "";
    }
    if(!state.modelManual && !state.model) state.model = DEFAULT_MODEL;
    saveState();
    updateTopSub();
  });

  // Characters
  const replySelect = $("replyAsSelect");
  if(replySelect){
    replySelect.addEventListener("change", e=>{
      const chat = getCurrentChat();
      if(!chat) return;
      chat.replyAs = e.target.value || "auto";
      touchChat(chat);
      saveState();
    });
  }
  const addCharBtn = $("btnAddChar");
  if(addCharBtn) addCharBtn.addEventListener("click", addCharacter);
  const forceReplyBtn = $("btnForceReply");
  if(forceReplyBtn) forceReplyBtn.addEventListener("click", forceReply);

  // Scene & Style
  const sceneInput = $("sceneSetting");
  if(sceneInput){
    sceneInput.addEventListener("input", e=>{
      const chat = getCurrentChat();
      if(!chat) return;
      chat.scene = e.target.value;
      touchChat(chat);
      saveState();
    });
  }
  const styleInput = $("styleRules");
  if(styleInput){
    styleInput.addEventListener("input", e=>{
      const chat = getCurrentChat();
      if(!chat) return;
      chat.style = e.target.value;
      touchChat(chat);
      saveState();
    });
  }

  // Lore
  $("loreJson").addEventListener("input", e=>{
    const chat = getCurrentChat();
    if(!chat) return;
    chat.loreJson = e.target.value;
    touchChat(chat);
    saveState();
  });

  // Generation controls
  $("temp").addEventListener("input", e=>{
    const chat = getCurrentChat();
    if(!chat) return;
    chat.gen.temperature = parseFloat(e.target.value || "0.9");
    touchChat(chat);
    saveState();
  });
  $("maxTokens").addEventListener("input", e=>{
    const chat = getCurrentChat();
    if(!chat) return;
    chat.gen.max_tokens = parseInt(e.target.value || "600", 10);
    touchChat(chat);
    saveState();
  });
  $("topP").addEventListener("input", e=>{
    const chat = getCurrentChat();
    if(!chat) return;
    chat.gen.top_p = parseFloat(e.target.value || "0.9");
    touchChat(chat);
    saveState();
  });
  $("presence").addEventListener("input", e=>{
    const chat = getCurrentChat();
    if(!chat) return;
    chat.gen.presence_penalty = parseFloat(e.target.value || "0.2");
    touchChat(chat);
    saveState();
  });
  $("streamToggle").addEventListener("change", e=>{
    const chat = getCurrentChat();
    if(!chat) return;
    chat.gen.stream = !!e.target.checked;
    touchChat(chat);
    saveState();
  });

  // Chat actions
  $("btnClear").addEventListener("click", ()=>{
    const chat = getCurrentChat();
    if(!chat) return;
    if(!confirm("Clear chat?")) return;
    chat.messages = [];
    touchChat(chat);
    saveState();
    renderChat({ preserveScroll: true });
    renderChatList();
  });

  $("btnExport").addEventListener("click", exportChat);
  $("btnImport").addEventListener("click", importChat);
  const newChatBtn = $("btnNewChat");
  if(newChatBtn) newChatBtn.addEventListener("click", createNewChat);
  $("btnSidebar").addEventListener("click", toggleSidebar);
  const sidebarInsideBtn = $("btnSidebarInside");
  if(sidebarInsideBtn) sidebarInsideBtn.addEventListener("click", toggleSidebar);
  const sidebarBackdrop = $("sidebarBackdrop");
  if(sidebarBackdrop) sidebarBackdrop.addEventListener("click", ()=>{ if(state.sidebarOpen) toggleSidebar(); });

  $("btnSend").addEventListener("click", sendUserMessage);
  $("btnRegen").addEventListener("click", regenerateLast);
  $("btnStop").addEventListener("click", stopGeneration);

  inputEl.addEventListener("keydown", (e)=>{
    if(e.key === "Enter" && !e.shiftKey){
      e.preventDefault();
      sendUserMessage();
    }
  });
}

function updateModeFields(){
  $("directFields").style.display = state.mode === "direct" ? "block" : "none";
  $("proxyFields").style.display = state.mode === "proxy" ? "block" : "none";
}

function getCurrentChat(){
  let chat = state.chats.find(c=>c.id === state.currentChatId);
  if(!chat && state.chats.length){
    chat = state.chats[0];
    state.currentChatId = chat.id;
  }
  return chat;
}

function touchChat(chat){
  if(chat) chat.updatedAt = Date.now();
}

function getPrimaryCharacter(chat){
  return chat?.characters?.[0] || null;
}

function getCharacterById(chat, id){
  return (chat?.characters || []).find(c=>c.id === id) || null;
}

function updateChatTitle(chat){
  if(!chat) return;
  const primary = getPrimaryCharacter(chat);
  const name = (primary?.name || "").trim();
  chat.title = name || chat.title || "New Chat";
}

function pickAutoCharacter(chat, userText){
  const text = String(userText || "").toLowerCase();
  const lastAssistant = [...(chat?.messages || [])].reverse().find(m=>m.role === "assistant" && m.characterId);
  const lastCharId = lastAssistant?.characterId || null;

  let best = null;
  let bestScore = -1;
  for(const c of (chat?.characters || [])){
    let score = 0;
    const name = (c.name || "").toLowerCase();
    if(name && text.includes(name)) score += 4;
    if(c.id === lastCharId) score += 3;
    if(c.id === chat.lastReplyCharacterId) score += 1;
    if(score > bestScore){
      bestScore = score;
      best = c;
    }
  }
  return best || getPrimaryCharacter(chat);
}

function resolveReplyCharacter(chat, userText, forcedId){
  if(!chat) return null;
  if(forcedId){
    return getCharacterById(chat, forcedId) || getPrimaryCharacter(chat);
  }
  if(chat.replyAs && chat.replyAs !== "auto"){
    return getCharacterById(chat, chat.replyAs) || getPrimaryCharacter(chat);
  }
  return pickAutoCharacter(chat, userText);
}

function renderReplySelect(){
  const select = $("replyAsSelect");
  if(!select) return;
  const chat = getCurrentChat();
  if(!chat) return;
  select.innerHTML = "";
  const autoOpt = document.createElement("option");
  autoOpt.value = "auto";
  autoOpt.textContent = "Auto (best match)";
  select.appendChild(autoOpt);

  (chat.characters || []).forEach((c, idx)=>{
    const opt = document.createElement("option");
    opt.value = c.id;
    opt.textContent = c.name || `Character ${idx + 1}`;
    select.appendChild(opt);
  });

  select.value = chat.replyAs || "auto";
  if(select.value !== chat.replyAs){
    select.value = "auto";
    chat.replyAs = "auto";
    saveState();
  }
}

function renderCharacterList(){
  const list = $("characterList");
  if(!list) return;
  const chat = getCurrentChat();
  if(!chat) return;
  list.innerHTML = "";

  const makeLabel = (text)=>{
    const label = document.createElement("label");
    label.textContent = text;
    return label;
  };
  const makeInput = (value, placeholder, onInput)=>{
    const input = document.createElement("input");
    input.value = value || "";
    if(placeholder) input.placeholder = placeholder;
    input.addEventListener("input", onInput);
    return input;
  };
  const makeTextarea = (value, placeholder, onInput)=>{
    const textarea = document.createElement("textarea");
    textarea.value = value || "";
    if(placeholder) textarea.placeholder = placeholder;
    textarea.addEventListener("input", onInput);
    return textarea;
  };

  (chat.characters || []).forEach((char, idx)=>{
    const card = document.createElement("div");
    card.className = "charCard";
    card.dataset.charId = char.id;

    const header = document.createElement("div");
    header.className = "charHeader";

    const nameInput = makeInput(char.name, `Character ${idx + 1}`, (e)=>{
      char.name = e.target.value;
      updateChatTitle(chat);
      touchChat(chat);
      saveState();
      updateTopTitle();
      renderReplySelect();
      renderChatList();
      renderChat({ preserveScroll: true });
    });
    nameInput.classList.add("charNameInput");

    const actions = document.createElement("div");
    actions.className = "charActions";

    const toggleBtn = document.createElement("button");
    toggleBtn.className = "secondary charToggle";
    const isCollapsed = !!chat.characterCollapsed?.[char.id];
    toggleBtn.textContent = isCollapsed ? "Show" : "Hide";
    toggleBtn.addEventListener("click", ()=>{
      chat.characterCollapsed[char.id] = !chat.characterCollapsed[char.id];
      touchChat(chat);
      saveState();
      renderCharacterList();
    });

    const delBtn = document.createElement("button");
    delBtn.className = "danger charDelete";
    delBtn.textContent = "Delete";
    delBtn.addEventListener("click", ()=>{
      deleteCharacter(char.id);
    });

    actions.appendChild(toggleBtn);
    actions.appendChild(delBtn);
    header.appendChild(nameInput);
    header.appendChild(actions);
    card.appendChild(header);

    const body = document.createElement("div");
    body.className = "charBody";
    body.style.display = isCollapsed ? "none" : "block";

    body.appendChild(makeLabel("Persona (who they are)"));
    body.appendChild(makeTextarea(char.persona, "Core personality, voice, quirks...", (e)=>{
      char.persona = e.target.value;
      touchChat(chat);
      saveState();
    }));

    card.appendChild(body);
    list.appendChild(card);
  });
}

function addCharacter(){
  const chat = getCurrentChat();
  if(!chat) return;
  const next = (chat.characters?.length || 0) + 1;
  const char = createCharacter({ name: `Character ${next}` });
  chat.characters.push(char);
  touchChat(chat);
  saveState();
  renderReplySelect();
  renderCharacterList();
}

function deleteCharacter(id){
  const chat = getCurrentChat();
  if(!chat) return;
  if(chat.characters.length <= 1){
    toast("Keep at least one character.");
    return;
  }
  if(!confirm("Delete this character?")) return;
  const fallback = chat.characters.find(c=>c.id !== id);
  chat.characters = chat.characters.filter(c=>c.id !== id);
  if(chat.replyAs === id) chat.replyAs = "auto";
  if(chat.lastReplyCharacterId === id) chat.lastReplyCharacterId = null;
  if(chat.characterCollapsed) delete chat.characterCollapsed[id];
  if(fallback){
    chat.messages.forEach(m=>{
      if(m.characterId === id) m.characterId = fallback.id;
    });
  }
  updateChatTitle(chat);
  touchChat(chat);
  saveState();
  renderReplySelect();
  renderCharacterList();
  renderChat({ preserveScroll: true });
  renderChatList();
  updateTopTitle();
}

function getLastUserMessage(chat){
  return [...(chat?.messages || [])].reverse().find(m=>m.role === "user" && (m.content || "").trim());
}

function forceReply(){
  const chat = getCurrentChat();
  if(!chat) return;
  const lastUser = getLastUserMessage(chat);
  if(!lastUser){
    toast("No user message to reply to.");
    return;
  }
  const select = $("replyAsSelect");
  const forcedId = select && select.value && select.value !== "auto" ? select.value : null;
  const target = resolveReplyCharacter(chat, lastUser.content, forcedId);
  if(!target){
    toast("Add a character first.");
    return;
  }
  generateAssistantReply({ characterId: target.id, userText: lastUser.content });
}

function tryAutoLoadModels(){
  if(modelsAutoLoaded) return;
  if(state.mode === "direct" && !state.apiKey) return;
  if(state.mode === "proxy" && !state.proxyBase) return;
  modelsAutoLoaded = true;
  loadModels();
}

function applySidebarTab(){
  const tab = state.sidebarTab;
  document.querySelectorAll(".chatsPanel").forEach(panel=>{
    panel.style.display = tab === "chats" ? "block" : "none";
  });
  document.querySelectorAll(".currentPanel").forEach(panel=>{
    panel.style.display = tab === "current" ? "block" : "none";
  });
  document.querySelectorAll(".settingsPanel").forEach(panel=>{
    panel.style.display = tab === "settings" ? "block" : "none";
  });
  document.querySelectorAll("#sidebarTabs .tab").forEach(tab=>{
    tab.classList.toggle("active", tab.dataset.tab === state.sidebarTab);
  });
}

function applySidebarState(){
  if(state.sidebarOpen){
    appEl.classList.add("sidebar-open");
    appEl.classList.remove("sidebar-hidden");
  }else{
    appEl.classList.remove("sidebar-open");
    appEl.classList.add("sidebar-hidden");
  }
}

function applyCharacterCardCollapse(){
  const body = document.querySelector("[data-body=\"character\"]");
  const btn = document.querySelector(".panelToggle[data-target=\"character\"]");
  if(!body || !btn) return;
  body.style.display = state.charCardCollapsed ? "none" : "block";
  btn.textContent = state.charCardCollapsed ? "Show" : "Hide";
}

function toggleSidebar(){
  state.sidebarOpen = !state.sidebarOpen;
  applySidebarState();
  saveState();
}

function renderAll(){
  updateModeFields();
  applySidebarTab();
  applySidebarState();
  renderSidebar();
  renderChat();
  updateTopTitle();
  updateTopSub();
  tryAutoLoadModels();
}

function renderSidebar(){
  const chat = getCurrentChat();
  $("apiKey").value = state.apiKey || "";
  $("proxyBase").value = state.proxyBase || "";

  renderReplySelect();
  renderCharacterList();

  $("sceneSetting").value = chat?.scene || "";
  $("styleRules").value = chat?.style || "";

  $("loreJson").value = chat?.loreJson || "[]";

  $("temp").value = chat?.gen?.temperature ?? 0.9;
  $("maxTokens").value = chat?.gen?.max_tokens ?? 600;
  $("topP").value = chat?.gen?.top_p ?? 0.9;
  $("presence").value = chat?.gen?.presence_penalty ?? 0.2;
  $("streamToggle").checked = !!chat?.gen?.stream;

  renderChatList();
  applyCharacterCardCollapse();
}

function getChatPreview(chat){
  const last = [...(chat?.messages || [])].reverse().find(m=>m.content && m.content.trim());
  if(!last) return "No messages yet";
  const text = last.content.replace(/\s+/g, " ").trim();
  return text.length > 60 ? text.slice(0, 57) + "..." : text;
}

function renderChatList(){
  const list = $("chatList");
  if(!list) return;
  list.innerHTML = "";
  const chats = [...state.chats].sort((a,b)=>(b.updatedAt || 0) - (a.updatedAt || 0));

  for(const chat of chats){
    updateChatTitle(chat);
    const item = document.createElement("div");
    item.className = "chatItem" + (chat.id === state.currentChatId ? " active" : "");
    item.addEventListener("click", ()=>switchChat(chat.id));

    const info = document.createElement("div");
    info.className = "chatInfo";
    const title = document.createElement("div");
    title.className = "chatTitle";
    title.textContent = chat.title || "New Chat";
    const meta = document.createElement("div");
    meta.className = "chatMeta";
    meta.textContent = getChatPreview(chat);

    const del = document.createElement("button");
    del.className = "chatDelete";
    del.textContent = "Delete";
    del.addEventListener("click", (e)=>{
      e.stopPropagation();
      deleteChat(chat.id);
    });

    info.appendChild(title);
    info.appendChild(meta);
    item.appendChild(info);
    item.appendChild(del);
    list.appendChild(item);
  }
}

function createNewChat(){
  const chat = createChat();
  state.chats.unshift(chat);
  state.currentChatId = chat.id;
  editingIndex = null;
  saveState();
  renderAll();
}

function switchChat(id){
  if(id === state.currentChatId) return;
  state.currentChatId = id;
  editingIndex = null;
  saveState();
  renderAll();
}

function deleteChat(id){
  const chat = state.chats.find(c=>c.id === id);
  if(!chat) return;
  if(!confirm("Delete this chat?")) return;
  state.chats = state.chats.filter(c=>c.id !== id);
  if(!state.chats.length){
    const newChat = createChat();
    state.chats = [newChat];
    state.currentChatId = newChat.id;
  }else if(state.currentChatId === id){
    state.currentChatId = state.chats[0].id;
  }
  editingIndex = null;
  saveState();
  renderAll();
}

function renderChat(options = {}){
  const preserveScroll = !!options.preserveScroll;
  const prevTop = preserveScroll ? chatEl.scrollTop : 0;
  const prevHeight = preserveScroll ? chatEl.scrollHeight : 0;

  const chat = getCurrentChat();
  chatEl.innerHTML = "";
  (chat?.messages || []).forEach((m, idx)=>{
    chatEl.appendChild(renderMessage(chat, m, idx));
  });

  if(preserveScroll){
    const delta = chatEl.scrollHeight - prevHeight;
    chatEl.scrollTop = prevTop + delta;
  }else{
    scrollToBottom();
  }
}

function autoSizeTextArea(el){
  if(!el) return;
  el.style.height = "auto";
  el.style.height = `${el.scrollHeight}px`;
}

function escapeHTML(str){
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function sanitizeUrl(url){
  const trimmed = String(url || "").trim();
  if(!trimmed) return "";
  if(/^(https?:|mailto:)/i.test(trimmed)) return trimmed;
  return "";
}

function renderMarkdown(md){
  if(!md) return "";
  let text = escapeHTML(md);

  const codeBlocks = [];
  text = text.replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code)=>{
    const cleanLang = (lang || "").trim().toLowerCase();
    const safeLang = /^[a-z0-9+-]+$/.test(cleanLang) ? cleanLang : "";
    const idx = codeBlocks.length;
    codeBlocks.push({ lang: safeLang, code: code.replace(/\n$/, "") });
    return `\n{{{CODEBLOCK_${idx}}}}\n`;
  });

  const inlineCodes = [];
  text = text.replace(/`([^`\n]+)`/g, (match, code)=>{
    const idx = inlineCodes.length;
    inlineCodes.push(code);
    return `{{{INLINECODE_${idx}}}}`;
  });

  text = text.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
  text = text.replace(/__([^_]+)__/g, "<strong>$1</strong>");
  text = text.replace(/\*([^*\n]+)\*/g, "<em>$1</em>");
  text = text.replace(/_([^_\n]+)_/g, "<em>$1</em>");

  text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, label, url)=>{
    const safe = sanitizeUrl(url);
    if(!safe) return `${label} (${url})`;
    return `<a href="${safe}" target="_blank" rel="noopener noreferrer">${label}</a>`;
  });

  const lines = text.split(/\r?\n/);
  const out = [];
  let inList = null;
  let para = [];

  const flushPara = ()=>{
    if(para.length){
      out.push(`<p>${para.join("<br>")}</p>`);
      para = [];
    }
  };
  const closeList = ()=>{
    if(inList){
      out.push(`</${inList}>`);
      inList = null;
    }
  };

  for(const line of lines){
    const trimmed = line.trim();
    const codeMatch = trimmed.match(/^\{\{\{CODEBLOCK_(\d+)\}\}\}$/);
    if(codeMatch){
      flushPara();
      closeList();
      out.push(trimmed);
      continue;
    }

    const ulMatch = line.match(/^\s*[-*]\s+(.+)/);
    const olMatch = line.match(/^\s*\d+\.\s+(.+)/);
    if(ulMatch){
      flushPara();
      if(inList !== "ul"){
        closeList();
        inList = "ul";
        out.push("<ul>");
      }
      out.push(`<li>${ulMatch[1].trim()}</li>`);
      continue;
    }
    if(olMatch){
      flushPara();
      if(inList !== "ol"){
        closeList();
        inList = "ol";
        out.push("<ol>");
      }
      out.push(`<li>${olMatch[1].trim()}</li>`);
      continue;
    }

    if(trimmed === ""){
      flushPara();
      closeList();
      continue;
    }

    closeList();
    para.push(line);
  }

  flushPara();
  closeList();

  let html = out.join("\n");

  html = html.replace(/\{\{\{CODEBLOCK_(\d+)\}\}\}/g, (match, idx)=>{
    const block = codeBlocks[Number(idx)];
    if(!block) return "";
    const langClass = block.lang ? ` class="lang-${block.lang}"` : "";
    return `<pre><code${langClass}>${block.code}</code></pre>`;
  });

  html = html.replace(/\{\{\{INLINECODE_(\d+)\}\}\}/g, (match, idx)=>{
    const code = inlineCodes[Number(idx)];
    return typeof code === "string" ? `<code>${code}</code>` : "";
  });

  return html;
}

function renderMessage(chat, m, idx){
  const wrap = document.createElement("div");
  wrap.className = "msg";

  const avatar = document.createElement("div");
  avatar.className = "avatar";
  const character = m.role === "assistant" ? getCharacterById(chat, m.characterId) : null;
  const charInitial = character?.name?.slice(0,1)?.toUpperCase() || "A";
  avatar.textContent = m.role === "user" ? "U" : charInitial;

  const bubble = document.createElement("div");
  bubble.className = "bubble " + (m.role === "user" ? "user" : "assistant");
  const isEditing = editingIndex === idx;
  if(isEditing){
    const editBox = document.createElement("textarea");
    editBox.className = "editBox";
    editBox.value = m.content || "";
    autoSizeTextArea(editBox);
    requestAnimationFrame(()=>autoSizeTextArea(editBox));
    editBox.addEventListener("input", ()=>autoSizeTextArea(editBox));
    editBox.addEventListener("keydown", (e)=>{
      if(e.key === "Escape"){
        e.preventDefault();
        cancelEditMessage();
      }
    });

    const editActions = document.createElement("div");
    editActions.className = "editActions";
    const btnSave = document.createElement("button");
    btnSave.textContent = "Save";
    btnSave.addEventListener("click", ()=>saveEditMessage(idx, editBox.value));
    const btnCancel = document.createElement("button");
    btnCancel.className = "secondary";
    btnCancel.textContent = "Cancel";
    btnCancel.addEventListener("click", cancelEditMessage);

    editActions.appendChild(btnSave);
    editActions.appendChild(btnCancel);
    bubble.appendChild(editBox);
    bubble.appendChild(editActions);
  }else{
    bubble.innerHTML = renderMarkdown(m.content || "");
  }

  // meta
  const meta = document.createElement("div");
  meta.className = "metaLine";
  const left = document.createElement("div");
  left.textContent = m.role === "user" ? "You" : (character?.name || "Assistant");
  const right = document.createElement("div");
  right.className = "mono";
  right.textContent = m._streaming ? "streaming..." : "";

  meta.appendChild(left);
  meta.appendChild(right);

  bubble.appendChild(meta);

  if(!isEditing && !m._streaming){
    const actions = document.createElement("div");
    actions.className = "msgActions";

    const btnEdit = document.createElement("button");
    btnEdit.textContent = "Edit";
    btnEdit.addEventListener("click", (e)=>{
      e.stopPropagation();
      startEditMessage(idx);
    });

    const btnGen = document.createElement("button");
    btnGen.textContent = m.role === "assistant" ? "Regenerate" : "Generate";
    btnGen.addEventListener("click", (e)=>{
      e.stopPropagation();
      regenerateFromIndex(idx);
    });

    const btnDelete = document.createElement("button");
    btnDelete.textContent = "Delete";
    btnDelete.addEventListener("click", (e)=>{
      e.stopPropagation();
      deleteMessage(idx);
    });

    actions.appendChild(btnEdit);
    actions.appendChild(btnGen);
    actions.appendChild(btnDelete);
    bubble.appendChild(actions);
  }

  if(!isEditing && !m._streaming && m.role === "assistant" && Array.isArray(m._variants) && m._variants.length > 1){
    const nav = document.createElement("div");
    nav.className = "variantNav";
    const btnPrev = document.createElement("button");
    btnPrev.textContent = "<";
    btnPrev.addEventListener("click", (e)=>{
      e.stopPropagation();
      cycleVariant(idx, -1);
    });
    const label = document.createElement("div");
    label.textContent = `${(m._variantIndex || 0) + 1} / ${m._variants.length}`;
    const btnNext = document.createElement("button");
    btnNext.textContent = ">";
    btnNext.addEventListener("click", (e)=>{
      e.stopPropagation();
      cycleVariant(idx, 1);
    });

    nav.appendChild(btnPrev);
    nav.appendChild(label);
    nav.appendChild(btnNext);
    bubble.appendChild(nav);
  }

  wrap.appendChild(avatar);
  wrap.appendChild(bubble);

  return wrap;
}

function updateTopTitle(){
  const chat = getCurrentChat();
  $("topTitle").textContent = chat?.title || "RP Chat";
}
function updateTopSub(){
  const model = getModel();
  const modeLabel = state.mode === "direct" ? "Direct (key in browser)" : "Proxy (safe)";
  $("topSub").textContent = `${modeLabel} • Model: ${model || "(none)"}`;
}

function getModel(){
  return state.modelManual || state.model || "";
}

function toast(msg){
  statusEl.textContent = msg;
  setTimeout(()=>{ statusEl.textContent = "Tip: Enter sends • Shift+Enter newline"; }, 2200);
}

function scrollToBottom(){
  chatEl.scrollTop = chatEl.scrollHeight;
}

function stopGeneration(){
  if(aborter){
    aborter.abort();
    aborter = null;
    toast("Stopped ✋");
    // clear streaming flags
    const chat = getCurrentChat();
    if(chat) chat.messages.forEach(m=>delete m._streaming);
    renderChat();
  }
}

function ensureVariants(msg){
  if(!msg || msg.role !== "assistant") return;
  if(!Array.isArray(msg._variants) || msg._variants.length === 0){
    msg._variants = [msg.content || ""];
    msg._variantIndex = 0;
  }else if(typeof msg._variantIndex !== "number" || msg._variantIndex < 0 || msg._variantIndex >= msg._variants.length){
    msg._variantIndex = msg._variants.length - 1;
  }
}

function finalizeAssistantMessage(msg){
  if(!msg || msg.role !== "assistant") return;
  if(!Array.isArray(msg._variants)) msg._variants = [];
  msg._variants.push(msg.content || "");
  msg._variantIndex = msg._variants.length - 1;
}

function cycleVariant(idx, dir){
  const chat = getCurrentChat();
  if(!chat) return;
  const msg = chat.messages[idx];
  if(!msg || msg.role !== "assistant") return;
  ensureVariants(msg);
  if(msg._variants.length < 2) return;
  let next = msg._variantIndex + dir;
  if(next < 0) next = msg._variants.length - 1;
  if(next >= msg._variants.length) next = 0;
  msg._variantIndex = next;
  msg.content = msg._variants[next] || "";
  saveState();
  renderChat();
}

async function sendUserMessage(){
  const text = inputEl.value.trim();
  if(!text) return;

  inputEl.value = "";

  const chat = getCurrentChat();
  if(!chat) return;
  chat.messages.push({ role:"user", content: text });
  touchChat(chat);
  saveState();
  renderChat();
  renderChatList();

  const target = resolveReplyCharacter(chat, text);
  await generateAssistantReply({ characterId: target?.id, userText: text });
}

async function regenerateLast(){
  // remove last assistant message if it exists
  const chat = getCurrentChat();
  if(!chat) return;
  for(let i = chat.messages.length - 1; i >= 0; i--){
    if(chat.messages[i].role === "assistant"){
      await regenerateFromIndex(i);
      return;
    }
    if(chat.messages[i].role === "user") break;
  }
}

function startEditMessage(idx){
  const chat = getCurrentChat();
  if(!chat) return;
  const msg = chat.messages[idx];
  if(!msg || msg._streaming) return;
  editingIndex = idx;
  renderChat({ preserveScroll: true });
}

function deleteMessage(idx){
  const chat = getCurrentChat();
  if(!chat) return;
  if(idx < 0 || idx >= chat.messages.length) return;
  if(!confirm("Delete this message?")) return;
  chat.messages.splice(idx, 1);
  touchChat(chat);
  if(editingIndex === idx) editingIndex = null;
  saveState();
  renderChat({ preserveScroll: true });
  renderChatList();
}

function saveEditMessage(idx, next){
  const chat = getCurrentChat();
  if(!chat) return;
  const msg = chat.messages[idx];
  if(!msg) return;
  msg.content = next;
  if(msg.role === "assistant"){
    ensureVariants(msg);
    const vi = msg._variantIndex ?? (msg._variants.length - 1);
    msg._variants[vi] = next;
    msg._variantIndex = vi;
  }
  touchChat(chat);
  editingIndex = null;
  saveState();
  renderChat({ preserveScroll: true });
  renderChatList();
}

function cancelEditMessage(){
  editingIndex = null;
  renderChat({ preserveScroll: true });
}

async function regenerateFromIndex(idx){
  const chat = getCurrentChat();
  if(!chat) return;
  if(idx < 0 || idx >= chat.messages.length) return;
  const target = chat.messages[idx];
  if(!target || target._streaming) return;

  const keepCount = target.role === "assistant" ? idx + 1 : idx + 1;
  chat.messages = chat.messages.slice(0, keepCount);
  touchChat(chat);

  if(target.role === "assistant"){
    const charId = target.characterId || resolveReplyCharacter(chat, "", null)?.id;
    if(charId && !target.characterId) target.characterId = charId;
    ensureVariants(target);
    target._streaming = true;
    target.content = "";
    saveState();
    renderChat();
    renderChatList();
    await generateAssistantReply({ assistantMsg: target, characterId: charId });
    return;
  }

  const replyChar = resolveReplyCharacter(chat, target.content);
  const assistantMsg = { role:"assistant", content:"", _streaming:true, characterId: replyChar?.id };
  chat.messages.push(assistantMsg);
  saveState();
  renderChat();
  await generateAssistantReply({ assistantMsg, characterId: replyChar?.id, userText: target.content });
}

function buildSystemPrompt(character, chat){
  const c = character || {};
  const lines = [];

  lines.push(`You are roleplaying as "${c.name || "Assistant"}".`);
  lines.push(`Only speak and act as "${c.name || "Assistant"}".`);
  lines.push(`Never mention being an AI or policies. Stay fully in character.`);
  lines.push(`No out-of-character commentary unless the user explicitly asks for OOC.`);
  lines.push("");

  if(c.persona?.trim()){
    lines.push("PERSONA:");
    lines.push(c.persona.trim());
    lines.push("");
  }
  if(chat?.scene?.trim()){
    lines.push("SCENE / SETTING:");
    lines.push(chat.scene.trim());
    lines.push("");
  }
  if(chat?.style?.trim()){
    lines.push("STYLE RULES (GLOBAL):");
    lines.push(chat.style.trim());
    lines.push("");
  }

  lines.push("IMPORTANT:");
  lines.push("- Keep the roleplay immersive.");
  lines.push("- Maintain continuity and emotional realism.");
  lines.push("- If the user asks to change tone/pace, obey.");

  if(chat?.characters?.length > 1){
    const others = chat.characters
      .filter(x=>x.id !== c.id)
      .map(x=>x.name)
      .filter(Boolean);
    if(others.length){
      lines.push("");
      lines.push(`Other characters in this chat: ${others.join(", ")}.`);
      lines.push("Do not speak for them or write their dialogue.");
    }
  }

  return lines.join("\n");
}

function safeParseLore(){
  try{
    const chat = getCurrentChat();
    const arr = JSON.parse(chat?.loreJson || "[]");
    return Array.isArray(arr) ? arr : [];
  }catch{
    return [];
  }
}

function pickLoreSnippets(){
  const lore = safeParseLore();
  if(!lore.length) return [];

  // Search last few messages for keywords
  const chat = getCurrentChat();
  const recent = (chat?.messages || []).slice(-8).map(m=>m.content || "").join("\n").toLowerCase();

  const hits = [];
  for(const entry of lore){
    const keys = (entry.keys || []).map(k=>String(k).toLowerCase()).filter(Boolean);
    const text = String(entry.text || "").trim();
    if(!keys.length || !text) continue;

    if(keys.some(k => recent.includes(k))){
      hits.push(text);
    }
  }

  // de-dupe
  return [...new Set(hits)].slice(0, 6);
}

function buildMessagesForAPI(characterId){
  const chat = getCurrentChat();
  const character = getCharacterById(chat, characterId) || getPrimaryCharacter(chat);
  const systemPrompt = buildSystemPrompt(character, chat);

  const loreSnips = pickLoreSnippets();
  const loreBlock = loreSnips.length
    ? "WORLD LORE (only use if relevant):\n- " + loreSnips.join("\n- ")
    : "";

  const sys = [
    { role:"system", content: systemPrompt },
    ...(loreBlock ? [{ role:"system", content: loreBlock }] : [])
  ];

  // Keep last N messages for context
  const thread = (chat?.messages || [])
    .slice(-30)
    .filter(m => m.role !== "assistant" || (m.content && m.content.trim().length > 0))
    .map(m=>{
      if(m.role === "user") return `User: ${m.content || ""}`;
      const c = getCharacterById(chat, m.characterId);
      const name = c?.name || "Assistant";
      return `${name}: ${m.content || ""}`;
    })
    .join("\n\n");

  const threadMsg = thread
    ? [{ role: "user", content: `CHAT THREAD (most recent last):\n${thread}` }]
    : [];

  return [...sys, ...threadMsg];
}

async function generateAssistantReply(options = {}){
  const chat = getCurrentChat();
  if(!chat) return;
  const userText = options.userText || "";
  const forcedId = options.characterId || options.assistantMsg?.characterId || null;
  const targetCharacter = resolveReplyCharacter(chat, userText, forcedId);
  if(!targetCharacter){
    toast("Add a character first.");
    return;
  }
  const model = getModel();
  if(!model){
    toast("Pick a model first (Load Models) ⚠️");
    return;
  }
  if(state.mode === "direct" && !state.apiKey){
    toast("Paste your OpenRouter API key ⚠️");
    return;
  }
  if(state.mode === "proxy" && !state.proxyBase){
    toast("Set Proxy Base URL ⚠️");
    return;
  }

  // Create placeholder assistant message for streaming UI
  const assistantMsg = options.assistantMsg || { role:"assistant", content:"", _streaming:true };
  if(!options.assistantMsg){
    chat.messages.push(assistantMsg);
  }else{
    assistantMsg._streaming = true;
  }
  assistantMsg.characterId = targetCharacter.id;
  touchChat(chat);
  saveState();
  renderChat();

  aborter = new AbortController();

  const payload = {
    model,
    messages: buildMessagesForAPI(targetCharacter.id),
    temperature: chat.gen.temperature,
    max_tokens: chat.gen.max_tokens,
    top_p: chat.gen.top_p,
    presence_penalty: chat.gen.presence_penalty,
    stream: !!chat.gen.stream
  };

  try{
    if(payload.stream){
      await callChatStream(payload, (delta)=>{
        assistantMsg.content += delta;
        saveState();
        renderChat(); // simple + reliable; you can optimize later
      });
    }else{
      const full = await callChat(payload);
      assistantMsg.content = full;
      saveState();
      renderChat();
    }

    assistantMsg._streaming = false;
    finalizeAssistantMessage(assistantMsg);
    chat.lastReplyCharacterId = targetCharacter.id;
    touchChat(chat);
    saveState();
    renderChat();
    renderChatList();
    toast("Done ✅");
  }catch(err){
    assistantMsg._streaming = false;
    assistantMsg.content = assistantMsg.content || "";
    touchChat(chat);
    saveState();
    renderChat();
    renderChatList();

    toast("Error: " + (err?.message || String(err)));
  }finally{
    aborter = null;
    scrollToBottom();
  }
}

function buildHeaders(apiKey){
  return {
    "Content-Type":"application/json",
    "Authorization": "Bearer " + apiKey,
  };
}

async function callChat(payload){
  const url = state.mode === "direct"
    ? "https://openrouter.ai/api/v1/chat/completions"
    : (state.proxyBase.replace(/\/$/,"") + "/api/chat");

  const res = await fetch(url, {
    method:"POST",
    headers: state.mode === "direct" ? buildHeaders(state.apiKey) : {"Content-Type":"application/json"},
    body: JSON.stringify(payload),
    signal: aborter?.signal
  });

  if(!res.ok){
    const text = await res.text().catch(()=>"(no body)");
    throw new Error(`HTTP ${res.status}: ${text}`);
  }

  const data = await res.json();
  const msg = data?.choices?.[0]?.message?.content;
  if(typeof msg !== "string") throw new Error("Bad response shape (no choices[0].message.content)");
  return msg;
}

async function callChatStream(payload, onDelta){
  const url = state.mode === "direct"
    ? "https://openrouter.ai/api/v1/chat/completions"
    : (state.proxyBase.replace(/\/$/,"") + "/api/chat");

  const res = await fetch(url, {
    method:"POST",
    headers: state.mode === "direct" ? buildHeaders(state.apiKey) : {"Content-Type":"application/json"},
    body: JSON.stringify(payload),
    signal: aborter?.signal
  });

  if(!res.ok){
    const text = await res.text().catch(()=>"(no body)");
    throw new Error(`HTTP ${res.status}: ${text}`);
  }

  // SSE text/event-stream
  const reader = res.body.getReader();
  const decoder = new TextDecoder("utf-8");
  let buffer = "";

  while(true){
    const {value, done} = await reader.read();
    if(done) break;

    buffer += decoder.decode(value, {stream:true});
    const lines = buffer.split("\n");
    buffer = lines.pop() || "";

    for(const line of lines){
      const l = line.trim();

      // ignore comments/keep-alives
      if(!l || l.startsWith(":")) continue;

      if(l.startsWith("data:")){
        const dataStr = l.slice(5).trim();
        if(dataStr === "[DONE]") return;

        let obj;
        try{
          obj = JSON.parse(dataStr);
        }catch{
          continue;
        }

        const choice = obj?.choices?.[0];
        // streaming chunk: choices[0].delta.content :contentReference[oaicite:4]{index=4}
        const delta = choice?.delta?.content;
        const err = choice?.error;

        if(err){
          throw new Error(err.message || "Stream error");
        }
        if(typeof delta === "string" && delta.length){
          onDelta(delta);
        }
      }
    }
  }
}

/* MODELS */
async function loadModels(){
  try{
    toast("Loading models…");
    const models = await fetchModels();
    const select = $("modelSelect");
    select.innerHTML = `<option value="">(select a model)</option>`;

    // sort by name
    models.sort((a,b)=>String(a.id).localeCompare(String(b.id)));

    for(const m of models.slice(0, 400)){
      const opt = document.createElement("option");
      opt.value = m.id;
      opt.textContent = m.id;
      select.appendChild(opt);
    }
    if(!state.modelManual && state.model){
      select.value = state.model;
      if(select.value !== state.model) select.value = "";
    }
    toast(`Loaded ${models.length} models ✅`);
  }catch(err){
    toast("Models error: " + (err?.message || String(err)));
  }
}

async function fetchModels(){
  if(state.mode === "direct" && !state.apiKey) throw new Error("Paste your API key first.");
  if(state.mode === "proxy" && !state.proxyBase) throw new Error("Set Proxy Base URL first.");

  const url = state.mode === "direct"
    ? "https://openrouter.ai/api/v1/models"
    : (state.proxyBase.replace(/\/$/,"") + "/api/models");

  const res = await fetch(url, {
    headers: state.mode === "direct" ? buildHeaders(state.apiKey) : {}
  });

  if(!res.ok){
    const text = await res.text().catch(()=>"(no body)");
    throw new Error(`HTTP ${res.status}: ${text}`);
  }

  const data = await res.json();
  const arr = data?.data || data?.models || [];
  return arr.map(x=>({ id: x.id || x.model || x.name || "" })).filter(x=>x.id);
}

async function testConnection(){
  try{
    toast("Testing…");
    // lightweight call: load models list head
    const models = await fetchModels();
    toast(`Connected ✅ (models: ${models.length})`);
    updateTopSub();
  }catch(err){
    toast("Connection failed: " + (err?.message || String(err)));
  }
}

/* EXPORT / IMPORT */
function exportChat(){
  const chat = getCurrentChat();
  if(!chat) return;
  const blob = new Blob([JSON.stringify({
    characters: chat.characters,
    scene: chat.scene,
    style: chat.style,
    loreJson: chat.loreJson,
    gen: chat.gen,
    messages: chat.messages,
    replyAs: chat.replyAs,
    lastReplyCharacterId: chat.lastReplyCharacterId
  }, null, 2)], {type:"application/json"});

  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  const primary = getPrimaryCharacter(chat);
  const base = (primary?.name || chat.title || "chat").toLowerCase().replace(/\s+/g,"_");
  a.download = `rpchat_${base}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
}

function importChat(){
  const inp = document.createElement("input");
  inp.type = "file";
  inp.accept = "application/json";
  inp.onchange = async ()=>{
    const file = inp.files?.[0];
    if(!file) return;
    const text = await file.text();
    const obj = JSON.parse(text);

    const chat = getCurrentChat();
    if(!chat) return;
    if(Array.isArray(obj.characters)) chat.characters = obj.characters;
    if(obj.char && !obj.characters) chat.characters = [createCharacter(obj.char)];
    if(typeof obj.scene === "string") chat.scene = obj.scene;
    if(typeof obj.style === "string") chat.style = obj.style;
    if(obj.loreJson) chat.loreJson = obj.loreJson;
    if(obj.gen) chat.gen = obj.gen;
    if(Array.isArray(obj.messages)) chat.messages = obj.messages;
    if(obj.replyAs) chat.replyAs = obj.replyAs;
    if(obj.lastReplyCharacterId) chat.lastReplyCharacterId = obj.lastReplyCharacterId;
    normalizeChat(chat);
    updateChatTitle(chat);
    touchChat(chat);

    saveState();
    renderAll();
    toast("Imported ✅");
  };
  inp.click();
}

/* STORAGE */
function saveState(){
  localStorage.setItem(LS_KEY, JSON.stringify(state));
}
function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    return raw ? JSON.parse(raw) : null;
  }catch{
    return null;
  }
}
</script>
</body>
</html>
